// This is a generated file. Not intended for manual editing.
package org.vlang.lang;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import org.vlang.lang.psi.VlangCompositeElementType;
import org.vlang.lang.stubs.VlangElementTypeFactory;
import org.vlang.lang.psi.VlangTokenType;
import org.vlang.lang.psi.impl.*;

public interface VlangTypes {

  IElementType ADD_EXPR = new VlangCompositeElementType("ADD_EXPR");
  IElementType ALIAS_TYPE = VlangElementTypeFactory.stubFactory("ALIAS_TYPE");
  IElementType AND_EXPR = new VlangCompositeElementType("AND_EXPR");
  IElementType ANONYMOUS_STRUCT_TYPE = VlangElementTypeFactory.stubFactory("ANONYMOUS_STRUCT_TYPE");
  IElementType ANONYMOUS_STRUCT_VALUE_EXPRESSION = new VlangCompositeElementType("ANONYMOUS_STRUCT_VALUE_EXPRESSION");
  IElementType APPEND_STATEMENT = new VlangCompositeElementType("APPEND_STATEMENT");
  IElementType ARGUMENT_LIST = new VlangCompositeElementType("ARGUMENT_LIST");
  IElementType ARRAY_CREATION = new VlangCompositeElementType("ARRAY_CREATION");
  IElementType ARRAY_CREATION_LIST = new VlangCompositeElementType("ARRAY_CREATION_LIST");
  IElementType ARRAY_TYPE = VlangElementTypeFactory.stubFactory("ARRAY_TYPE");
  IElementType ASM_BLOCK = new VlangCompositeElementType("ASM_BLOCK");
  IElementType ASM_BLOCK_STATEMENT = new VlangCompositeElementType("ASM_BLOCK_STATEMENT");
  IElementType ASSERT_STATEMENT = new VlangCompositeElementType("ASSERT_STATEMENT");
  IElementType ASSIGNMENT_STATEMENT = new VlangCompositeElementType("ASSIGNMENT_STATEMENT");
  IElementType ASSIGN_OP = new VlangCompositeElementType("ASSIGN_OP");
  IElementType AS_EXPRESSION = new VlangCompositeElementType("AS_EXPRESSION");
  IElementType ATOMIC_TYPE = VlangElementTypeFactory.stubFactory("ATOMIC_TYPE");
  IElementType ATTRIBUTE = VlangElementTypeFactory.stubFactory("ATTRIBUTE");
  IElementType ATTRIBUTES = VlangElementTypeFactory.stubFactory("ATTRIBUTES");
  IElementType ATTRIBUTE_EXPRESSION = VlangElementTypeFactory.stubFactory("ATTRIBUTE_EXPRESSION");
  IElementType ATTRIBUTE_IDENTIFIER = new VlangCompositeElementType("ATTRIBUTE_IDENTIFIER");
  IElementType ATTRIBUTE_IDENTIFIER_PREFIX = new VlangCompositeElementType("ATTRIBUTE_IDENTIFIER_PREFIX");
  IElementType ATTRIBUTE_KEY = VlangElementTypeFactory.stubFactory("ATTRIBUTE_KEY");
  IElementType ATTRIBUTE_VALUE = VlangElementTypeFactory.stubFactory("ATTRIBUTE_VALUE");
  IElementType BLOCK = new VlangCompositeElementType("BLOCK");
  IElementType BREAK_STATEMENT = new VlangCompositeElementType("BREAK_STATEMENT");
  IElementType CALL_EXPR = new VlangCompositeElementType("CALL_EXPR");
  IElementType CALL_EXPR_WITH_PROPAGATE = new VlangCompositeElementType("CALL_EXPR_WITH_PROPAGATE");
  IElementType CAPTURE = new VlangCompositeElementType("CAPTURE");
  IElementType CAPTURE_LIST = new VlangCompositeElementType("CAPTURE_LIST");
  IElementType CHANNEL_TYPE = VlangElementTypeFactory.stubFactory("CHANNEL_TYPE");
  IElementType COMPILE_TIME_ELSE_BRANCH = new VlangCompositeElementType("COMPILE_TIME_ELSE_BRANCH");
  IElementType COMPILE_TIME_FIELD_REFERENCE = new VlangCompositeElementType("COMPILE_TIME_FIELD_REFERENCE");
  IElementType COMPILE_TIME_FOR_STATEMENT = new VlangCompositeElementType("COMPILE_TIME_FOR_STATEMENT");
  IElementType COMPILE_TIME_IF_EXPRESSION = new VlangCompositeElementType("COMPILE_TIME_IF_EXPRESSION");
  IElementType CONDITIONAL_EXPR = new VlangCompositeElementType("CONDITIONAL_EXPR");
  IElementType CONST_DECLARATION = new VlangCompositeElementType("CONST_DECLARATION");
  IElementType CONST_DEFINITION = VlangElementTypeFactory.stubFactory("CONST_DEFINITION");
  IElementType CONTINUE_STATEMENT = new VlangCompositeElementType("CONTINUE_STATEMENT");
  IElementType DEFAULT_FIELD_VALUE = new VlangCompositeElementType("DEFAULT_FIELD_VALUE");
  IElementType DEFER_STATEMENT = new VlangCompositeElementType("DEFER_STATEMENT");
  IElementType DOT_EXPRESSION = new VlangCompositeElementType("DOT_EXPRESSION");
  IElementType DUMP_CALL_EXPR = new VlangCompositeElementType("DUMP_CALL_EXPR");
  IElementType ELEMENT = new VlangCompositeElementType("ELEMENT");
  IElementType ELSE_BRANCH = new VlangCompositeElementType("ELSE_BRANCH");
  IElementType EMBEDDED_DEFINITION = VlangElementTypeFactory.stubFactory("EMBEDDED_DEFINITION");
  IElementType EMBEDDED_INTERFACE_DEFINITION = VlangElementTypeFactory.stubFactory("EMBEDDED_INTERFACE_DEFINITION");
  IElementType EMPTY_SLICE = new VlangCompositeElementType("EMPTY_SLICE");
  IElementType ENUM_BACKED_TYPE_AS = new VlangCompositeElementType("ENUM_BACKED_TYPE_AS");
  IElementType ENUM_DECLARATION = VlangElementTypeFactory.stubFactory("ENUM_DECLARATION");
  IElementType ENUM_FETCH = new VlangCompositeElementType("ENUM_FETCH");
  IElementType ENUM_FIELD_DECLARATION = new VlangCompositeElementType("ENUM_FIELD_DECLARATION");
  IElementType ENUM_FIELD_DEFINITION = VlangElementTypeFactory.stubFactory("ENUM_FIELD_DEFINITION");
  IElementType ENUM_TYPE = VlangElementTypeFactory.stubFactory("ENUM_TYPE");
  IElementType EXPRESSION = new VlangCompositeElementType("EXPRESSION");
  IElementType FIELDS_GROUP = new VlangCompositeElementType("FIELDS_GROUP");
  IElementType FIELD_DECLARATION = new VlangCompositeElementType("FIELD_DECLARATION");
  IElementType FIELD_DEFINITION = VlangElementTypeFactory.stubFactory("FIELD_DEFINITION");
  IElementType FIELD_NAME = new VlangCompositeElementType("FIELD_NAME");
  IElementType FIXED_SIZE_ARRAY_TYPE = VlangElementTypeFactory.stubFactory("FIXED_SIZE_ARRAY_TYPE");
  IElementType FORMAT_SPECIFIER = new VlangCompositeElementType("FORMAT_SPECIFIER");
  IElementType FORMAT_SPECIFIER_EXPRESSION = new VlangCompositeElementType("FORMAT_SPECIFIER_EXPRESSION");
  IElementType FORMAT_SPECIFIER_LEFT_ALIGN_FLAG = new VlangCompositeElementType("FORMAT_SPECIFIER_LEFT_ALIGN_FLAG");
  IElementType FORMAT_SPECIFIER_LETTER = new VlangCompositeElementType("FORMAT_SPECIFIER_LETTER");
  IElementType FORMAT_SPECIFIER_RIGHT_ALIGN_FLAG = new VlangCompositeElementType("FORMAT_SPECIFIER_RIGHT_ALIGN_FLAG");
  IElementType FORMAT_SPECIFIER_WIDTH_AND_PRECISION = new VlangCompositeElementType("FORMAT_SPECIFIER_WIDTH_AND_PRECISION");
  IElementType FOR_CLAUSE = new VlangCompositeElementType("FOR_CLAUSE");
  IElementType FOR_STATEMENT = new VlangCompositeElementType("FOR_STATEMENT");
  IElementType FUNCTION_DECLARATION = VlangElementTypeFactory.stubFactory("FUNCTION_DECLARATION");
  IElementType FUNCTION_LIT = new VlangCompositeElementType("FUNCTION_LIT");
  IElementType FUNCTION_TYPE = VlangElementTypeFactory.stubFactory("FUNCTION_TYPE");
  IElementType GENERIC_ARGUMENTS = new VlangCompositeElementType("GENERIC_ARGUMENTS");
  IElementType GENERIC_PARAMETER = VlangElementTypeFactory.stubFactory("GENERIC_PARAMETER");
  IElementType GENERIC_PARAMETERS = VlangElementTypeFactory.stubFactory("GENERIC_PARAMETERS");
  IElementType GENERIC_PARAMETER_LIST = new VlangCompositeElementType("GENERIC_PARAMETER_LIST");
  IElementType GLOBAL_VARIABLE_DECLARATION = new VlangCompositeElementType("GLOBAL_VARIABLE_DECLARATION");
  IElementType GLOBAL_VARIABLE_DEFINITION = VlangElementTypeFactory.stubFactory("GLOBAL_VARIABLE_DEFINITION");
  IElementType GOTO_STATEMENT = new VlangCompositeElementType("GOTO_STATEMENT");
  IElementType GO_EXPRESSION = new VlangCompositeElementType("GO_EXPRESSION");
  IElementType GUARD_VAR_DECLARATION = new VlangCompositeElementType("GUARD_VAR_DECLARATION");
  IElementType IF_ATTRIBUTE = new VlangCompositeElementType("IF_ATTRIBUTE");
  IElementType IF_EXPRESSION = new VlangCompositeElementType("IF_EXPRESSION");
  IElementType IMPORT_ALIAS = VlangElementTypeFactory.stubFactory("IMPORT_ALIAS");
  IElementType IMPORT_ALIAS_NAME = new VlangCompositeElementType("IMPORT_ALIAS_NAME");
  IElementType IMPORT_DECLARATION = new VlangCompositeElementType("IMPORT_DECLARATION");
  IElementType IMPORT_LIST = new VlangCompositeElementType("IMPORT_LIST");
  IElementType IMPORT_NAME = VlangElementTypeFactory.stubFactory("IMPORT_NAME");
  IElementType IMPORT_PATH = new VlangCompositeElementType("IMPORT_PATH");
  IElementType IMPORT_SPEC = new VlangCompositeElementType("IMPORT_SPEC");
  IElementType INC_DEC_EXPRESSION = new VlangCompositeElementType("INC_DEC_EXPRESSION");
  IElementType INDEX_OR_SLICE_EXPR = new VlangCompositeElementType("INDEX_OR_SLICE_EXPR");
  IElementType INTERFACE_DECLARATION = VlangElementTypeFactory.stubFactory("INTERFACE_DECLARATION");
  IElementType INTERFACE_METHOD_DECLARATION = new VlangCompositeElementType("INTERFACE_METHOD_DECLARATION");
  IElementType INTERFACE_METHOD_DEFINITION = VlangElementTypeFactory.stubFactory("INTERFACE_METHOD_DEFINITION");
  IElementType INTERFACE_TYPE = VlangElementTypeFactory.stubFactory("INTERFACE_TYPE");
  IElementType IN_EXPRESSION = new VlangCompositeElementType("IN_EXPRESSION");
  IElementType IS_EXPRESSION = new VlangCompositeElementType("IS_EXPRESSION");
  IElementType IS_REF_TYPE_CALL_EXPR = new VlangCompositeElementType("IS_REF_TYPE_CALL_EXPR");
  IElementType JSON_ARGUMENT_LIST = new VlangCompositeElementType("JSON_ARGUMENT_LIST");
  IElementType JSON_CALL_EXPR = new VlangCompositeElementType("JSON_CALL_EXPR");
  IElementType KEY = new VlangCompositeElementType("KEY");
  IElementType KEY_VALUE = new VlangCompositeElementType("KEY_VALUE");
  IElementType KEY_VALUES = new VlangCompositeElementType("KEY_VALUES");
  IElementType LABELED_STATEMENT = new VlangCompositeElementType("LABELED_STATEMENT");
  IElementType LABEL_DEFINITION = VlangElementTypeFactory.stubFactory("LABEL_DEFINITION");
  IElementType LABEL_REF = new VlangCompositeElementType("LABEL_REF");
  IElementType LEFT_HAND_EXPR_LIST = new VlangCompositeElementType("LEFT_HAND_EXPR_LIST");
  IElementType LITERAL = new VlangCompositeElementType("LITERAL");
  IElementType LITERAL_VALUE_EXPRESSION = new VlangCompositeElementType("LITERAL_VALUE_EXPRESSION");
  IElementType LOCK_EXPRESSION = new VlangCompositeElementType("LOCK_EXPRESSION");
  IElementType LOCK_PARTS = new VlangCompositeElementType("LOCK_PARTS");
  IElementType LONG_STRING_TEMPLATE_ENTRY = new VlangCompositeElementType("LONG_STRING_TEMPLATE_ENTRY");
  IElementType MAP_INIT_EXPR = new VlangCompositeElementType("MAP_INIT_EXPR");
  IElementType MAP_TYPE = VlangElementTypeFactory.stubFactory("MAP_TYPE");
  IElementType MATCH_ARM = new VlangCompositeElementType("MATCH_ARM");
  IElementType MATCH_ARMS = new VlangCompositeElementType("MATCH_ARMS");
  IElementType MATCH_ELSE_ARM_CLAUSE = new VlangCompositeElementType("MATCH_ELSE_ARM_CLAUSE");
  IElementType MATCH_EXPRESSION = new VlangCompositeElementType("MATCH_EXPRESSION");
  IElementType MEMBERS_GROUP = new VlangCompositeElementType("MEMBERS_GROUP");
  IElementType MEMBER_MODIFIER = new VlangCompositeElementType("MEMBER_MODIFIER");
  IElementType MEMBER_MODIFIERS = new VlangCompositeElementType("MEMBER_MODIFIERS");
  IElementType METHOD_DECLARATION = VlangElementTypeFactory.stubFactory("METHOD_DECLARATION");
  IElementType METHOD_NAME = new VlangCompositeElementType("METHOD_NAME");
  IElementType MODULE_CLAUSE = VlangElementTypeFactory.stubFactory("MODULE_CLAUSE");
  IElementType MUL_EXPR = new VlangCompositeElementType("MUL_EXPR");
  IElementType MUT_EXPRESSION = new VlangCompositeElementType("MUT_EXPRESSION");
  IElementType NONE_TYPE = VlangElementTypeFactory.stubFactory("NONE_TYPE");
  IElementType NOT_IN_EXPRESSION = new VlangCompositeElementType("NOT_IN_EXPRESSION");
  IElementType NOT_IS_EXPRESSION = new VlangCompositeElementType("NOT_IS_EXPRESSION");
  IElementType OFFSET_OF_CALL_EXPR = new VlangCompositeElementType("OFFSET_OF_CALL_EXPR");
  IElementType OPTION_PROPAGATION_EXPRESSION = new VlangCompositeElementType("OPTION_PROPAGATION_EXPRESSION");
  IElementType OPTION_TYPE = VlangElementTypeFactory.stubFactory("OPTION_TYPE");
  IElementType OR_BLOCK_EXPR = new VlangCompositeElementType("OR_BLOCK_EXPR");
  IElementType OR_EXPR = new VlangCompositeElementType("OR_EXPR");
  IElementType PARAMETERS = VlangElementTypeFactory.stubFactory("PARAMETERS");
  IElementType PARAM_DEFINITION = VlangElementTypeFactory.stubFactory("PARAM_DEFINITION");
  IElementType PARENTHESES_EXPR = new VlangCompositeElementType("PARENTHESES_EXPR");
  IElementType PLAIN_ATTRIBUTE = VlangElementTypeFactory.stubFactory("PLAIN_ATTRIBUTE");
  IElementType POINTER_TYPE = VlangElementTypeFactory.stubFactory("POINTER_TYPE");
  IElementType RANGE_CLAUSE = new VlangCompositeElementType("RANGE_CLAUSE");
  IElementType RANGE_EXPR = new VlangCompositeElementType("RANGE_EXPR");
  IElementType RECEIVER = VlangElementTypeFactory.stubFactory("RECEIVER");
  IElementType REFERENCE_EXPRESSION = new VlangCompositeElementType("REFERENCE_EXPRESSION");
  IElementType RESULT = VlangElementTypeFactory.stubFactory("RESULT");
  IElementType RESULT_PROPAGATION_EXPRESSION = new VlangCompositeElementType("RESULT_PROPAGATION_EXPRESSION");
  IElementType RESULT_TYPE = VlangElementTypeFactory.stubFactory("RESULT_TYPE");
  IElementType RETURN_STATEMENT = new VlangCompositeElementType("RETURN_STATEMENT");
  IElementType SELECTIVE_IMPORT_LIST = new VlangCompositeElementType("SELECTIVE_IMPORT_LIST");
  IElementType SELECT_ARM = new VlangCompositeElementType("SELECT_ARM");
  IElementType SELECT_ARMS = new VlangCompositeElementType("SELECT_ARMS");
  IElementType SELECT_ARM_ASSIGNMENT_STATEMENT = new VlangCompositeElementType("SELECT_ARM_ASSIGNMENT_STATEMENT");
  IElementType SELECT_ARM_STATEMENT = new VlangCompositeElementType("SELECT_ARM_STATEMENT");
  IElementType SELECT_ELSE_ARM_CLAUSE = new VlangCompositeElementType("SELECT_ELSE_ARM_CLAUSE");
  IElementType SELECT_EXPRESSION = new VlangCompositeElementType("SELECT_EXPRESSION");
  IElementType SEND_EXPR = new VlangCompositeElementType("SEND_EXPR");
  IElementType SEND_STATEMENT = new VlangCompositeElementType("SEND_STATEMENT");
  IElementType SHARED_EXPRESSION = new VlangCompositeElementType("SHARED_EXPRESSION");
  IElementType SHARED_TYPE = VlangElementTypeFactory.stubFactory("SHARED_TYPE");
  IElementType SHEBANG_CLAUSE = new VlangCompositeElementType("SHEBANG_CLAUSE");
  IElementType SHIFT_LEFT_EXPR = new VlangCompositeElementType("SHIFT_LEFT_EXPR");
  IElementType SHIFT_LEFT_OP = new VlangCompositeElementType("SHIFT_LEFT_OP");
  IElementType SHORT_STRING_TEMPLATE_ENTRY = new VlangCompositeElementType("SHORT_STRING_TEMPLATE_ENTRY");
  IElementType SIGNATURE = VlangElementTypeFactory.stubFactory("SIGNATURE");
  IElementType SIMPLE_STATEMENT = new VlangCompositeElementType("SIMPLE_STATEMENT");
  IElementType SIZE_OF_CALL_EXPR = new VlangCompositeElementType("SIZE_OF_CALL_EXPR");
  IElementType SPAWN_EXPRESSION = new VlangCompositeElementType("SPAWN_EXPRESSION");
  IElementType SQL_BLOCK = new VlangCompositeElementType("SQL_BLOCK");
  IElementType SQL_BLOCK_STATEMENT = new VlangCompositeElementType("SQL_BLOCK_STATEMENT");
  IElementType SQL_CREATE_STATEMENT = new VlangCompositeElementType("SQL_CREATE_STATEMENT");
  IElementType SQL_DELETE_STATEMENT = new VlangCompositeElementType("SQL_DELETE_STATEMENT");
  IElementType SQL_DROP_STATEMENT = new VlangCompositeElementType("SQL_DROP_STATEMENT");
  IElementType SQL_EXPRESSION = new VlangCompositeElementType("SQL_EXPRESSION");
  IElementType SQL_FROM_CLAUSE = new VlangCompositeElementType("SQL_FROM_CLAUSE");
  IElementType SQL_INSERT_STATEMENT = new VlangCompositeElementType("SQL_INSERT_STATEMENT");
  IElementType SQL_LIMIT_CLAUSE = new VlangCompositeElementType("SQL_LIMIT_CLAUSE");
  IElementType SQL_OFFSET_CLAUSE = new VlangCompositeElementType("SQL_OFFSET_CLAUSE");
  IElementType SQL_ORDER_BY_CLAUSE = new VlangCompositeElementType("SQL_ORDER_BY_CLAUSE");
  IElementType SQL_REFERENCE_LIST = new VlangCompositeElementType("SQL_REFERENCE_LIST");
  IElementType SQL_REFERENCE_LIST_ITEM = new VlangCompositeElementType("SQL_REFERENCE_LIST_ITEM");
  IElementType SQL_SELECT_COUNT_CLAUSE = new VlangCompositeElementType("SQL_SELECT_COUNT_CLAUSE");
  IElementType SQL_SELECT_STATEMENT = new VlangCompositeElementType("SQL_SELECT_STATEMENT");
  IElementType SQL_TABLE_NAME = new VlangCompositeElementType("SQL_TABLE_NAME");
  IElementType SQL_UPDATE_ITEM = new VlangCompositeElementType("SQL_UPDATE_ITEM");
  IElementType SQL_UPDATE_LIST = new VlangCompositeElementType("SQL_UPDATE_LIST");
  IElementType SQL_UPDATE_STATEMENT = new VlangCompositeElementType("SQL_UPDATE_STATEMENT");
  IElementType SQL_WHERE_CLAUSE = new VlangCompositeElementType("SQL_WHERE_CLAUSE");
  IElementType STATEMENT = new VlangCompositeElementType("STATEMENT");
  IElementType STRING_LITERAL = new VlangCompositeElementType("STRING_LITERAL");
  IElementType STRING_TEMPLATE = new VlangCompositeElementType("STRING_TEMPLATE");
  IElementType STRING_TEMPLATE_ENTRY = new VlangCompositeElementType("STRING_TEMPLATE_ENTRY");
  IElementType STRUCT_DECLARATION = VlangElementTypeFactory.stubFactory("STRUCT_DECLARATION");
  IElementType STRUCT_TYPE = VlangElementTypeFactory.stubFactory("STRUCT_TYPE");
  IElementType SYMBOL_VISIBILITY = new VlangCompositeElementType("SYMBOL_VISIBILITY");
  IElementType THREAD_TYPE = VlangElementTypeFactory.stubFactory("THREAD_TYPE");
  IElementType TUPLE_TYPE = VlangElementTypeFactory.stubFactory("TUPLE_TYPE");
  IElementType TYPE = VlangElementTypeFactory.stubFactory("TYPE");
  IElementType TYPE_ALIAS_DECLARATION = VlangElementTypeFactory.stubFactory("TYPE_ALIAS_DECLARATION");
  IElementType TYPE_CAST_EXPRESSION = new VlangCompositeElementType("TYPE_CAST_EXPRESSION");
  IElementType TYPE_LIST_NO_PIN = new VlangCompositeElementType("TYPE_LIST_NO_PIN");
  IElementType TYPE_MODIFIER = new VlangCompositeElementType("TYPE_MODIFIER");
  IElementType TYPE_MODIFIERS = new VlangCompositeElementType("TYPE_MODIFIERS");
  IElementType TYPE_OF_CALL_EXPR = new VlangCompositeElementType("TYPE_OF_CALL_EXPR");
  IElementType TYPE_REFERENCE_EXPRESSION = VlangElementTypeFactory.stubFactory("TYPE_REFERENCE_EXPRESSION");
  IElementType TYPE_UNION_LIST = VlangElementTypeFactory.stubFactory("TYPE_UNION_LIST");
  IElementType UNARY_EXPR = new VlangCompositeElementType("UNARY_EXPR");
  IElementType UNFINISHED_MEMBER_MODIFIERS = new VlangCompositeElementType("UNFINISHED_MEMBER_MODIFIERS");
  IElementType UNPACKING_EXPRESSION = new VlangCompositeElementType("UNPACKING_EXPRESSION");
  IElementType UNSAFE_EXPRESSION = new VlangCompositeElementType("UNSAFE_EXPRESSION");
  IElementType VALUE = new VlangCompositeElementType("VALUE");
  IElementType VAR_DECLARATION = new VlangCompositeElementType("VAR_DECLARATION");
  IElementType VAR_DEFINITION = VlangElementTypeFactory.stubFactory("VAR_DEFINITION");
  IElementType VAR_MODIFIER = new VlangCompositeElementType("VAR_MODIFIER");
  IElementType VAR_MODIFIERS = new VlangCompositeElementType("VAR_MODIFIERS");
  IElementType WRONG_POINTER_TYPE = VlangElementTypeFactory.stubFactory("WRONG_POINTER_TYPE");

  IElementType AS = new VlangTokenType("as");
  IElementType ASM = new VlangTokenType("asm");
  IElementType ASM_LINE = new VlangTokenType("ASM_LINE");
  IElementType ASSERT = new VlangTokenType("assert");
  IElementType ASSIGN = new VlangTokenType("=");
  IElementType AT = new VlangTokenType("@");
  IElementType ATOMIC = new VlangTokenType("atomic");
  IElementType BACKTICK = new VlangTokenType("`");
  IElementType BIN = new VlangTokenType("bin");
  IElementType BIT_AND = new VlangTokenType("&");
  IElementType BIT_AND_ASSIGN = new VlangTokenType("&=");
  IElementType BIT_CLEAR = new VlangTokenType("&^");
  IElementType BIT_CLEAR_ASSIGN = new VlangTokenType("&^=");
  IElementType BIT_OR = new VlangTokenType("|");
  IElementType BIT_OR_ASSIGN = new VlangTokenType("|=");
  IElementType BIT_XOR = new VlangTokenType("^");
  IElementType BIT_XOR_ASSIGN = new VlangTokenType("^=");
  IElementType BREAK = new VlangTokenType("break");
  IElementType BUILTIN_GLOBAL = new VlangTokenType("__global");
  IElementType CASE = new VlangTokenType("case");
  IElementType CHAR = new VlangTokenType("char");
  IElementType CLOSING_QUOTE = new VlangTokenType("CLOSING_QUOTE");
  IElementType COLON = new VlangTokenType(":");
  IElementType COMMA = new VlangTokenType(",");
  IElementType COND_AND = new VlangTokenType("&&");
  IElementType COND_OR = new VlangTokenType("||");
  IElementType CONST = new VlangTokenType("const");
  IElementType CONTINUE = new VlangTokenType("continue");
  IElementType C_STRING = new VlangTokenType("c_string");
  IElementType DEFER = new VlangTokenType("defer");
  IElementType DOLLAR = new VlangTokenType("$");
  IElementType DOT = new VlangTokenType(".");
  IElementType DOUBLE_QUOTE = new VlangTokenType("\"");
  IElementType DUMP = new VlangTokenType("dump");
  IElementType ELSE = new VlangTokenType("else");
  IElementType ELSE_COMPILE_TIME = new VlangTokenType("$else");
  IElementType ENUM = new VlangTokenType("enum");
  IElementType EQ = new VlangTokenType("==");
  IElementType FALSE = new VlangTokenType("false");
  IElementType FLOAT = new VlangTokenType("float");
  IElementType FN = new VlangTokenType("fn");
  IElementType FOR = new VlangTokenType("for");
  IElementType FOR_COMPILE_TIME = new VlangTokenType("$for");
  IElementType GO = new VlangTokenType("go");
  IElementType GOTO = new VlangTokenType("goto");
  IElementType GREATER = new VlangTokenType(">");
  IElementType GREATER_OR_EQUAL = new VlangTokenType(">=");
  IElementType HASH_LBRACK = new VlangTokenType("#[");
  IElementType HEX = new VlangTokenType("hex");
  IElementType IDENTIFIER = new VlangTokenType("identifier");
  IElementType IF = new VlangTokenType("if");
  IElementType IF_COMPILE_TIME = new VlangTokenType("$if");
  IElementType IMPORT = new VlangTokenType("import");
  IElementType IN = new VlangTokenType("in");
  IElementType INT = new VlangTokenType("int");
  IElementType INTERFACE = new VlangTokenType("interface");
  IElementType IS = new VlangTokenType("is");
  IElementType ISREFTYPE = new VlangTokenType("isreftype");
  IElementType LBRACE = new VlangTokenType("{");
  IElementType LBRACK = new VlangTokenType("[");
  IElementType LESS = new VlangTokenType("<");
  IElementType LESS_OR_EQUAL = new VlangTokenType("<=");
  IElementType LITERAL_STRING_TEMPLATE_ENTRY = new VlangTokenType("LITERAL_STRING_TEMPLATE_ENTRY");
  IElementType LITERAL_STRING_TEMPLATE_ESCAPE_ENTRY = new VlangTokenType("LITERAL_STRING_TEMPLATE_ESCAPE_ENTRY");
  IElementType LOCK = new VlangTokenType("lock");
  IElementType LONG_TEMPLATE_ENTRY_START = new VlangTokenType("LONG_TEMPLATE_ENTRY_START");
  IElementType LPAREN = new VlangTokenType("(");
  IElementType MATCH = new VlangTokenType("match");
  IElementType MINUS = new VlangTokenType("-");
  IElementType MINUS_ASSIGN = new VlangTokenType("-=");
  IElementType MINUS_MINUS = new VlangTokenType("--");
  IElementType MODULE = new VlangTokenType("module");
  IElementType MUL = new VlangTokenType("*");
  IElementType MUL_ASSIGN = new VlangTokenType("*=");
  IElementType MUT = new VlangTokenType("mut");
  IElementType NIL = new VlangTokenType("nil");
  IElementType NONE = new VlangTokenType("none");
  IElementType NOT = new VlangTokenType("!");
  IElementType NOT_EQ = new VlangTokenType("!=");
  IElementType NOT_IN = new VlangTokenType("!in");
  IElementType NOT_IS = new VlangTokenType("!is");
  IElementType OCT = new VlangTokenType("oct");
  IElementType OFFSETOF = new VlangTokenType("offsetof");
  IElementType OPEN_QUOTE = new VlangTokenType("OPEN_QUOTE");
  IElementType OR = new VlangTokenType("or");
  IElementType PLUS = new VlangTokenType("+");
  IElementType PLUS_ASSIGN = new VlangTokenType("+=");
  IElementType PLUS_PLUS = new VlangTokenType("++");
  IElementType PUB = new VlangTokenType("pub");
  IElementType QUESTION = new VlangTokenType("?");
  IElementType QUOTIENT = new VlangTokenType("/");
  IElementType QUOTIENT_ASSIGN = new VlangTokenType("/=");
  IElementType RANGE = new VlangTokenType("..");
  IElementType RAW_STRING = new VlangTokenType("raw_string");
  IElementType RBRACE = new VlangTokenType("}");
  IElementType RBRACK = new VlangTokenType("]");
  IElementType RBRACK_EXP = new VlangTokenType("]!");
  IElementType REMAINDER = new VlangTokenType("%");
  IElementType REMAINDER_ASSIGN = new VlangTokenType("%=");
  IElementType RETURN = new VlangTokenType("return");
  IElementType RLOCK = new VlangTokenType("rlock");
  IElementType RPAREN = new VlangTokenType(")");
  IElementType SAFE_DOT = new VlangTokenType("?.");
  IElementType SELECT = new VlangTokenType("select");
  IElementType SEMICOLON = new VlangTokenType(";");
  IElementType SEMICOLON_SYNTHETIC = new VlangTokenType("<NL>");
  IElementType SEND_CHANNEL = new VlangTokenType("<-");
  IElementType SHARED = new VlangTokenType("shared");
  IElementType SHEBANG = new VlangTokenType("shebang");
  IElementType SHIFT_LEFT = new VlangTokenType("<<");
  IElementType SHIFT_LEFT_ASSIGN = new VlangTokenType("<<=");
  IElementType SHIFT_RIGHT = new VlangTokenType(">>");
  IElementType SHIFT_RIGHT_ASSIGN = new VlangTokenType(">>=");
  IElementType SHORT_TEMPLATE_ENTRY_START = new VlangTokenType("SHORT_TEMPLATE_ENTRY_START");
  IElementType SINGLE_QUOTE = new VlangTokenType("'");
  IElementType SIZEOF = new VlangTokenType("sizeof");
  IElementType SPAWN = new VlangTokenType("spawn");
  IElementType STATIC = new VlangTokenType("static");
  IElementType STRUCT = new VlangTokenType("struct");
  IElementType TEMPLATE_ENTRY_END = new VlangTokenType("TEMPLATE_ENTRY_END");
  IElementType TEMPLATE_ENTRY_START = new VlangTokenType("TEMPLATE_ENTRY_START");
  IElementType TILDA = new VlangTokenType("~");
  IElementType TRIPLE_DOT = new VlangTokenType("...");
  IElementType TRUE = new VlangTokenType("true");
  IElementType TYPEOF = new VlangTokenType("typeof");
  IElementType TYPE_ = new VlangTokenType("type");
  IElementType UNION = new VlangTokenType("union");
  IElementType UNSAFE = new VlangTokenType("unsafe");
  IElementType UNSIGNED_SHIFT_RIGHT = new VlangTokenType(">>>");
  IElementType UNSIGNED_SHIFT_RIGHT_ASSIGN = new VlangTokenType(">>>=");
  IElementType VAR = new VlangTokenType("var");
  IElementType VAR_ASSIGN = new VlangTokenType(":=");
  IElementType VOLATILE = new VlangTokenType("volatile");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
      if (type == ADD_EXPR) {
        return new VlangAddExprImpl(node);
      }
      else if (type == ALIAS_TYPE) {
        return new VlangAliasTypeImpl(node);
      }
      else if (type == AND_EXPR) {
        return new VlangAndExprImpl(node);
      }
      else if (type == ANONYMOUS_STRUCT_TYPE) {
        return new VlangAnonymousStructTypeImpl(node);
      }
      else if (type == ANONYMOUS_STRUCT_VALUE_EXPRESSION) {
        return new VlangAnonymousStructValueExpressionImpl(node);
      }
      else if (type == APPEND_STATEMENT) {
        return new VlangAppendStatementImpl(node);
      }
      else if (type == ARGUMENT_LIST) {
        return new VlangArgumentListImpl(node);
      }
      else if (type == ARRAY_CREATION) {
        return new VlangArrayCreationImpl(node);
      }
      else if (type == ARRAY_CREATION_LIST) {
        return new VlangArrayCreationListImpl(node);
      }
      else if (type == ARRAY_TYPE) {
        return new VlangArrayTypeImpl(node);
      }
      else if (type == ASM_BLOCK) {
        return new VlangAsmBlockImpl(node);
      }
      else if (type == ASM_BLOCK_STATEMENT) {
        return new VlangAsmBlockStatementImpl(node);
      }
      else if (type == ASSERT_STATEMENT) {
        return new VlangAssertStatementImpl(node);
      }
      else if (type == ASSIGNMENT_STATEMENT) {
        return new VlangAssignmentStatementImpl(node);
      }
      else if (type == ASSIGN_OP) {
        return new VlangAssignOpImpl(node);
      }
      else if (type == AS_EXPRESSION) {
        return new VlangAsExpressionImpl(node);
      }
      else if (type == ATOMIC_TYPE) {
        return new VlangAtomicTypeImpl(node);
      }
      else if (type == ATTRIBUTE) {
        return new VlangAttributeImpl(node);
      }
      else if (type == ATTRIBUTES) {
        return new VlangAttributesImpl(node);
      }
      else if (type == ATTRIBUTE_EXPRESSION) {
        return new VlangAttributeExpressionImpl(node);
      }
      else if (type == ATTRIBUTE_IDENTIFIER) {
        return new VlangAttributeIdentifierImpl(node);
      }
      else if (type == ATTRIBUTE_IDENTIFIER_PREFIX) {
        return new VlangAttributeIdentifierPrefixImpl(node);
      }
      else if (type == ATTRIBUTE_KEY) {
        return new VlangAttributeKeyImpl(node);
      }
      else if (type == ATTRIBUTE_VALUE) {
        return new VlangAttributeValueImpl(node);
      }
      else if (type == BLOCK) {
        return new VlangBlockImpl(node);
      }
      else if (type == BREAK_STATEMENT) {
        return new VlangBreakStatementImpl(node);
      }
      else if (type == CALL_EXPR) {
        return new VlangCallExprImpl(node);
      }
      else if (type == CALL_EXPR_WITH_PROPAGATE) {
        return new VlangCallExprWithPropagateImpl(node);
      }
      else if (type == CAPTURE) {
        return new VlangCaptureImpl(node);
      }
      else if (type == CAPTURE_LIST) {
        return new VlangCaptureListImpl(node);
      }
      else if (type == CHANNEL_TYPE) {
        return new VlangChannelTypeImpl(node);
      }
      else if (type == COMPILE_TIME_ELSE_BRANCH) {
        return new VlangCompileTimeElseBranchImpl(node);
      }
      else if (type == COMPILE_TIME_FIELD_REFERENCE) {
        return new VlangCompileTimeFieldReferenceImpl(node);
      }
      else if (type == COMPILE_TIME_FOR_STATEMENT) {
        return new VlangCompileTimeForStatementImpl(node);
      }
      else if (type == COMPILE_TIME_IF_EXPRESSION) {
        return new VlangCompileTimeIfExpressionImpl(node);
      }
      else if (type == CONDITIONAL_EXPR) {
        return new VlangConditionalExprImpl(node);
      }
      else if (type == CONST_DECLARATION) {
        return new VlangConstDeclarationImpl(node);
      }
      else if (type == CONST_DEFINITION) {
        return new VlangConstDefinitionImpl(node);
      }
      else if (type == CONTINUE_STATEMENT) {
        return new VlangContinueStatementImpl(node);
      }
      else if (type == DEFAULT_FIELD_VALUE) {
        return new VlangDefaultFieldValueImpl(node);
      }
      else if (type == DEFER_STATEMENT) {
        return new VlangDeferStatementImpl(node);
      }
      else if (type == DOT_EXPRESSION) {
        return new VlangDotExpressionImpl(node);
      }
      else if (type == DUMP_CALL_EXPR) {
        return new VlangDumpCallExprImpl(node);
      }
      else if (type == ELEMENT) {
        return new VlangElementImpl(node);
      }
      else if (type == ELSE_BRANCH) {
        return new VlangElseBranchImpl(node);
      }
      else if (type == EMBEDDED_DEFINITION) {
        return new VlangEmbeddedDefinitionImpl(node);
      }
      else if (type == EMBEDDED_INTERFACE_DEFINITION) {
        return new VlangEmbeddedInterfaceDefinitionImpl(node);
      }
      else if (type == EMPTY_SLICE) {
        return new VlangEmptySliceImpl(node);
      }
      else if (type == ENUM_BACKED_TYPE_AS) {
        return new VlangEnumBackedTypeAsImpl(node);
      }
      else if (type == ENUM_DECLARATION) {
        return new VlangEnumDeclarationImpl(node);
      }
      else if (type == ENUM_FETCH) {
        return new VlangEnumFetchImpl(node);
      }
      else if (type == ENUM_FIELD_DECLARATION) {
        return new VlangEnumFieldDeclarationImpl(node);
      }
      else if (type == ENUM_FIELD_DEFINITION) {
        return new VlangEnumFieldDefinitionImpl(node);
      }
      else if (type == ENUM_TYPE) {
        return new VlangEnumTypeImpl(node);
      }
      else if (type == FIELDS_GROUP) {
        return new VlangFieldsGroupImpl(node);
      }
      else if (type == FIELD_DECLARATION) {
        return new VlangFieldDeclarationImpl(node);
      }
      else if (type == FIELD_DEFINITION) {
        return new VlangFieldDefinitionImpl(node);
      }
      else if (type == FIELD_NAME) {
        return new VlangFieldNameImpl(node);
      }
      else if (type == FIXED_SIZE_ARRAY_TYPE) {
        return new VlangFixedSizeArrayTypeImpl(node);
      }
      else if (type == FORMAT_SPECIFIER) {
        return new VlangFormatSpecifierImpl(node);
      }
      else if (type == FORMAT_SPECIFIER_EXPRESSION) {
        return new VlangFormatSpecifierExpressionImpl(node);
      }
      else if (type == FORMAT_SPECIFIER_LEFT_ALIGN_FLAG) {
        return new VlangFormatSpecifierLeftAlignFlagImpl(node);
      }
      else if (type == FORMAT_SPECIFIER_LETTER) {
        return new VlangFormatSpecifierLetterImpl(node);
      }
      else if (type == FORMAT_SPECIFIER_RIGHT_ALIGN_FLAG) {
        return new VlangFormatSpecifierRightAlignFlagImpl(node);
      }
      else if (type == FORMAT_SPECIFIER_WIDTH_AND_PRECISION) {
        return new VlangFormatSpecifierWidthAndPrecisionImpl(node);
      }
      else if (type == FOR_CLAUSE) {
        return new VlangForClauseImpl(node);
      }
      else if (type == FOR_STATEMENT) {
        return new VlangForStatementImpl(node);
      }
      else if (type == FUNCTION_DECLARATION) {
        return new VlangFunctionDeclarationImpl(node);
      }
      else if (type == FUNCTION_LIT) {
        return new VlangFunctionLitImpl(node);
      }
      else if (type == FUNCTION_TYPE) {
        return new VlangFunctionTypeImpl(node);
      }
      else if (type == GENERIC_ARGUMENTS) {
        return new VlangGenericArgumentsImpl(node);
      }
      else if (type == GENERIC_PARAMETER) {
        return new VlangGenericParameterImpl(node);
      }
      else if (type == GENERIC_PARAMETERS) {
        return new VlangGenericParametersImpl(node);
      }
      else if (type == GENERIC_PARAMETER_LIST) {
        return new VlangGenericParameterListImpl(node);
      }
      else if (type == GLOBAL_VARIABLE_DECLARATION) {
        return new VlangGlobalVariableDeclarationImpl(node);
      }
      else if (type == GLOBAL_VARIABLE_DEFINITION) {
        return new VlangGlobalVariableDefinitionImpl(node);
      }
      else if (type == GOTO_STATEMENT) {
        return new VlangGotoStatementImpl(node);
      }
      else if (type == GO_EXPRESSION) {
        return new VlangGoExpressionImpl(node);
      }
      else if (type == GUARD_VAR_DECLARATION) {
        return new VlangGuardVarDeclarationImpl(node);
      }
      else if (type == IF_ATTRIBUTE) {
        return new VlangIfAttributeImpl(node);
      }
      else if (type == IF_EXPRESSION) {
        return new VlangIfExpressionImpl(node);
      }
      else if (type == IMPORT_ALIAS) {
        return new VlangImportAliasImpl(node);
      }
      else if (type == IMPORT_ALIAS_NAME) {
        return new VlangImportAliasNameImpl(node);
      }
      else if (type == IMPORT_DECLARATION) {
        return new VlangImportDeclarationImpl(node);
      }
      else if (type == IMPORT_LIST) {
        return new VlangImportListImpl(node);
      }
      else if (type == IMPORT_NAME) {
        return new VlangImportNameImpl(node);
      }
      else if (type == IMPORT_PATH) {
        return new VlangImportPathImpl(node);
      }
      else if (type == IMPORT_SPEC) {
        return new VlangImportSpecImpl(node);
      }
      else if (type == INC_DEC_EXPRESSION) {
        return new VlangIncDecExpressionImpl(node);
      }
      else if (type == INDEX_OR_SLICE_EXPR) {
        return new VlangIndexOrSliceExprImpl(node);
      }
      else if (type == INTERFACE_DECLARATION) {
        return new VlangInterfaceDeclarationImpl(node);
      }
      else if (type == INTERFACE_METHOD_DECLARATION) {
        return new VlangInterfaceMethodDeclarationImpl(node);
      }
      else if (type == INTERFACE_METHOD_DEFINITION) {
        return new VlangInterfaceMethodDefinitionImpl(node);
      }
      else if (type == INTERFACE_TYPE) {
        return new VlangInterfaceTypeImpl(node);
      }
      else if (type == IN_EXPRESSION) {
        return new VlangInExpressionImpl(node);
      }
      else if (type == IS_EXPRESSION) {
        return new VlangIsExpressionImpl(node);
      }
      else if (type == IS_REF_TYPE_CALL_EXPR) {
        return new VlangIsRefTypeCallExprImpl(node);
      }
      else if (type == JSON_ARGUMENT_LIST) {
        return new VlangJsonArgumentListImpl(node);
      }
      else if (type == JSON_CALL_EXPR) {
        return new VlangJsonCallExprImpl(node);
      }
      else if (type == KEY) {
        return new VlangKeyImpl(node);
      }
      else if (type == KEY_VALUE) {
        return new VlangKeyValueImpl(node);
      }
      else if (type == KEY_VALUES) {
        return new VlangKeyValuesImpl(node);
      }
      else if (type == LABELED_STATEMENT) {
        return new VlangLabeledStatementImpl(node);
      }
      else if (type == LABEL_DEFINITION) {
        return new VlangLabelDefinitionImpl(node);
      }
      else if (type == LABEL_REF) {
        return new VlangLabelRefImpl(node);
      }
      else if (type == LEFT_HAND_EXPR_LIST) {
        return new VlangLeftHandExprListImpl(node);
      }
      else if (type == LITERAL) {
        return new VlangLiteralImpl(node);
      }
      else if (type == LITERAL_VALUE_EXPRESSION) {
        return new VlangLiteralValueExpressionImpl(node);
      }
      else if (type == LOCK_EXPRESSION) {
        return new VlangLockExpressionImpl(node);
      }
      else if (type == LOCK_PARTS) {
        return new VlangLockPartsImpl(node);
      }
      else if (type == LONG_STRING_TEMPLATE_ENTRY) {
        return new VlangLongStringTemplateEntryImpl(node);
      }
      else if (type == MAP_INIT_EXPR) {
        return new VlangMapInitExprImpl(node);
      }
      else if (type == MAP_TYPE) {
        return new VlangMapTypeImpl(node);
      }
      else if (type == MATCH_ARM) {
        return new VlangMatchArmImpl(node);
      }
      else if (type == MATCH_ARMS) {
        return new VlangMatchArmsImpl(node);
      }
      else if (type == MATCH_ELSE_ARM_CLAUSE) {
        return new VlangMatchElseArmClauseImpl(node);
      }
      else if (type == MATCH_EXPRESSION) {
        return new VlangMatchExpressionImpl(node);
      }
      else if (type == MEMBERS_GROUP) {
        return new VlangMembersGroupImpl(node);
      }
      else if (type == MEMBER_MODIFIER) {
        return new VlangMemberModifierImpl(node);
      }
      else if (type == MEMBER_MODIFIERS) {
        return new VlangMemberModifiersImpl(node);
      }
      else if (type == METHOD_DECLARATION) {
        return new VlangMethodDeclarationImpl(node);
      }
      else if (type == METHOD_NAME) {
        return new VlangMethodNameImpl(node);
      }
      else if (type == MODULE_CLAUSE) {
        return new VlangModuleClauseImpl(node);
      }
      else if (type == MUL_EXPR) {
        return new VlangMulExprImpl(node);
      }
      else if (type == MUT_EXPRESSION) {
        return new VlangMutExpressionImpl(node);
      }
      else if (type == NONE_TYPE) {
        return new VlangNoneTypeImpl(node);
      }
      else if (type == NOT_IN_EXPRESSION) {
        return new VlangNotInExpressionImpl(node);
      }
      else if (type == NOT_IS_EXPRESSION) {
        return new VlangNotIsExpressionImpl(node);
      }
      else if (type == OFFSET_OF_CALL_EXPR) {
        return new VlangOffsetOfCallExprImpl(node);
      }
      else if (type == OPTION_PROPAGATION_EXPRESSION) {
        return new VlangOptionPropagationExpressionImpl(node);
      }
      else if (type == OPTION_TYPE) {
        return new VlangOptionTypeImpl(node);
      }
      else if (type == OR_BLOCK_EXPR) {
        return new VlangOrBlockExprImpl(node);
      }
      else if (type == OR_EXPR) {
        return new VlangOrExprImpl(node);
      }
      else if (type == PARAMETERS) {
        return new VlangParametersImpl(node);
      }
      else if (type == PARAM_DEFINITION) {
        return new VlangParamDefinitionImpl(node);
      }
      else if (type == PARENTHESES_EXPR) {
        return new VlangParenthesesExprImpl(node);
      }
      else if (type == PLAIN_ATTRIBUTE) {
        return new VlangPlainAttributeImpl(node);
      }
      else if (type == POINTER_TYPE) {
        return new VlangPointerTypeImpl(node);
      }
      else if (type == RANGE_CLAUSE) {
        return new VlangRangeClauseImpl(node);
      }
      else if (type == RANGE_EXPR) {
        return new VlangRangeExprImpl(node);
      }
      else if (type == RECEIVER) {
        return new VlangReceiverImpl(node);
      }
      else if (type == REFERENCE_EXPRESSION) {
        return new VlangReferenceExpressionImpl(node);
      }
      else if (type == RESULT) {
        return new VlangResultImpl(node);
      }
      else if (type == RESULT_PROPAGATION_EXPRESSION) {
        return new VlangResultPropagationExpressionImpl(node);
      }
      else if (type == RESULT_TYPE) {
        return new VlangResultTypeImpl(node);
      }
      else if (type == RETURN_STATEMENT) {
        return new VlangReturnStatementImpl(node);
      }
      else if (type == SELECTIVE_IMPORT_LIST) {
        return new VlangSelectiveImportListImpl(node);
      }
      else if (type == SELECT_ARM) {
        return new VlangSelectArmImpl(node);
      }
      else if (type == SELECT_ARMS) {
        return new VlangSelectArmsImpl(node);
      }
      else if (type == SELECT_ARM_ASSIGNMENT_STATEMENT) {
        return new VlangSelectArmAssignmentStatementImpl(node);
      }
      else if (type == SELECT_ARM_STATEMENT) {
        return new VlangSelectArmStatementImpl(node);
      }
      else if (type == SELECT_ELSE_ARM_CLAUSE) {
        return new VlangSelectElseArmClauseImpl(node);
      }
      else if (type == SELECT_EXPRESSION) {
        return new VlangSelectExpressionImpl(node);
      }
      else if (type == SEND_EXPR) {
        return new VlangSendExprImpl(node);
      }
      else if (type == SEND_STATEMENT) {
        return new VlangSendStatementImpl(node);
      }
      else if (type == SHARED_EXPRESSION) {
        return new VlangSharedExpressionImpl(node);
      }
      else if (type == SHARED_TYPE) {
        return new VlangSharedTypeImpl(node);
      }
      else if (type == SHEBANG_CLAUSE) {
        return new VlangShebangClauseImpl(node);
      }
      else if (type == SHIFT_LEFT_EXPR) {
        return new VlangShiftLeftExprImpl(node);
      }
      else if (type == SHIFT_LEFT_OP) {
        return new VlangShiftLeftOpImpl(node);
      }
      else if (type == SHORT_STRING_TEMPLATE_ENTRY) {
        return new VlangShortStringTemplateEntryImpl(node);
      }
      else if (type == SIGNATURE) {
        return new VlangSignatureImpl(node);
      }
      else if (type == SIMPLE_STATEMENT) {
        return new VlangSimpleStatementImpl(node);
      }
      else if (type == SIZE_OF_CALL_EXPR) {
        return new VlangSizeOfCallExprImpl(node);
      }
      else if (type == SPAWN_EXPRESSION) {
        return new VlangSpawnExpressionImpl(node);
      }
      else if (type == SQL_BLOCK) {
        return new VlangSqlBlockImpl(node);
      }
      else if (type == SQL_BLOCK_STATEMENT) {
        return new VlangSqlBlockStatementImpl(node);
      }
      else if (type == SQL_CREATE_STATEMENT) {
        return new VlangSqlCreateStatementImpl(node);
      }
      else if (type == SQL_DELETE_STATEMENT) {
        return new VlangSqlDeleteStatementImpl(node);
      }
      else if (type == SQL_DROP_STATEMENT) {
        return new VlangSqlDropStatementImpl(node);
      }
      else if (type == SQL_EXPRESSION) {
        return new VlangSqlExpressionImpl(node);
      }
      else if (type == SQL_FROM_CLAUSE) {
        return new VlangSqlFromClauseImpl(node);
      }
      else if (type == SQL_INSERT_STATEMENT) {
        return new VlangSqlInsertStatementImpl(node);
      }
      else if (type == SQL_LIMIT_CLAUSE) {
        return new VlangSqlLimitClauseImpl(node);
      }
      else if (type == SQL_OFFSET_CLAUSE) {
        return new VlangSqlOffsetClauseImpl(node);
      }
      else if (type == SQL_ORDER_BY_CLAUSE) {
        return new VlangSqlOrderByClauseImpl(node);
      }
      else if (type == SQL_REFERENCE_LIST) {
        return new VlangSqlReferenceListImpl(node);
      }
      else if (type == SQL_REFERENCE_LIST_ITEM) {
        return new VlangSqlReferenceListItemImpl(node);
      }
      else if (type == SQL_SELECT_COUNT_CLAUSE) {
        return new VlangSqlSelectCountClauseImpl(node);
      }
      else if (type == SQL_SELECT_STATEMENT) {
        return new VlangSqlSelectStatementImpl(node);
      }
      else if (type == SQL_TABLE_NAME) {
        return new VlangSqlTableNameImpl(node);
      }
      else if (type == SQL_UPDATE_ITEM) {
        return new VlangSqlUpdateItemImpl(node);
      }
      else if (type == SQL_UPDATE_LIST) {
        return new VlangSqlUpdateListImpl(node);
      }
      else if (type == SQL_UPDATE_STATEMENT) {
        return new VlangSqlUpdateStatementImpl(node);
      }
      else if (type == SQL_WHERE_CLAUSE) {
        return new VlangSqlWhereClauseImpl(node);
      }
      else if (type == STATEMENT) {
        return new VlangStatementImpl(node);
      }
      else if (type == STRING_LITERAL) {
        return new VlangStringLiteralImpl(node);
      }
      else if (type == STRING_TEMPLATE) {
        return new VlangStringTemplateImpl(node);
      }
      else if (type == STRING_TEMPLATE_ENTRY) {
        return new VlangStringTemplateEntryImpl(node);
      }
      else if (type == STRUCT_DECLARATION) {
        return new VlangStructDeclarationImpl(node);
      }
      else if (type == STRUCT_TYPE) {
        return new VlangStructTypeImpl(node);
      }
      else if (type == SYMBOL_VISIBILITY) {
        return new VlangSymbolVisibilityImpl(node);
      }
      else if (type == THREAD_TYPE) {
        return new VlangThreadTypeImpl(node);
      }
      else if (type == TUPLE_TYPE) {
        return new VlangTupleTypeImpl(node);
      }
      else if (type == TYPE) {
        return new VlangTypeImpl(node);
      }
      else if (type == TYPE_ALIAS_DECLARATION) {
        return new VlangTypeAliasDeclarationImpl(node);
      }
      else if (type == TYPE_CAST_EXPRESSION) {
        return new VlangTypeCastExpressionImpl(node);
      }
      else if (type == TYPE_LIST_NO_PIN) {
        return new VlangTypeListNoPinImpl(node);
      }
      else if (type == TYPE_MODIFIER) {
        return new VlangTypeModifierImpl(node);
      }
      else if (type == TYPE_MODIFIERS) {
        return new VlangTypeModifiersImpl(node);
      }
      else if (type == TYPE_OF_CALL_EXPR) {
        return new VlangTypeOfCallExprImpl(node);
      }
      else if (type == TYPE_REFERENCE_EXPRESSION) {
        return new VlangTypeReferenceExpressionImpl(node);
      }
      else if (type == TYPE_UNION_LIST) {
        return new VlangTypeUnionListImpl(node);
      }
      else if (type == UNARY_EXPR) {
        return new VlangUnaryExprImpl(node);
      }
      else if (type == UNFINISHED_MEMBER_MODIFIERS) {
        return new VlangUnfinishedMemberModifiersImpl(node);
      }
      else if (type == UNPACKING_EXPRESSION) {
        return new VlangUnpackingExpressionImpl(node);
      }
      else if (type == UNSAFE_EXPRESSION) {
        return new VlangUnsafeExpressionImpl(node);
      }
      else if (type == VALUE) {
        return new VlangValueImpl(node);
      }
      else if (type == VAR_DECLARATION) {
        return new VlangVarDeclarationImpl(node);
      }
      else if (type == VAR_DEFINITION) {
        return new VlangVarDefinitionImpl(node);
      }
      else if (type == VAR_MODIFIER) {
        return new VlangVarModifierImpl(node);
      }
      else if (type == VAR_MODIFIERS) {
        return new VlangVarModifiersImpl(node);
      }
      else if (type == WRONG_POINTER_TYPE) {
        return new VlangWrongPointerTypeImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
